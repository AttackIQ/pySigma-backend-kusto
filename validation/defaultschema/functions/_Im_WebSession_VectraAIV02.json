{"_Im_WebSession_VectraAIV02": {"body": "let parser = (starttime: datetime = datetime(null),\r\n              endtime: datetime = datetime(null),\r\n              srcipaddr_has_any_prefix: dynamic = dynamic([]),\r\n              ipaddr_has_any_prefix: dynamic = dynamic([]),\r\n              url_has_any: dynamic = dynamic([]),\r\n              httpuseragent_has_any: dynamic = dynamic([]),\r\n              eventresultdetails_in: dynamic = dynamic([]),\r\n              eventresult: string = '*',\r\n              disabled: bool = false,\r\n              pack:bool = false)\r\n{\r\n  let NetworkDirectionLookup = datatable(local_orig_b:bool, local_resp_b:bool, NetworkDirection:string)\r\n  [\r\n      false, true, 'Inbound',\r\n      true, false, 'Outbound',\r\n      true, true, 'Local',\r\n      false, false, 'Local'\r\n  ];\r\n  let NetworkProtocolVersionLookup = datatable(id_ip_ver_s:string, NetworkApplicationProtocol:string)\r\n  [\r\n      'ipv4', 'IPv4',\r\n      'ipv6', 'IPv6'\r\n  ];\r\n  let HostnameRegex = @'^[a-zA-Z0-9-]{1,61}$';\r\n  let remove_protocol_from_urls =  \r\n      materialize (\r\n          print url_has_any \r\n          | mv-apply l = print_0 to typeof(string) on ( \r\n            extend l = extract(@'^(?i:.*?://)?(.*)$', 1, l)\r\n          ) \r\n          | project l\r\n      );\r\n  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); \r\n  VectraStream_CL\r\n  | where not(disabled)\r\n  | where (isnull(starttime) or TimeGenerated >= starttime)\r\n      and (isnull(endtime) or TimeGenerated <= endtime)\r\n  | where metadata_type_s == 'metadata_httpsessioninfo'\r\n  | where \r\n      (array_length(url_has_any) == 0 \r\n      or host_s has_any(remove_protocol_from_urls) \r\n      or uri_s has_any (remove_protocol_from_urls) \r\n      or strcat(host_s, uri_s) has_any (remove_protocol_from_urls))\r\n  | where (array_length(httpuseragent_has_any) == 0 or user_agent_s has_any(httpuseragent_has_any))\r\n  | where (array_length(eventresultdetails_in) == 0 or tostring(status_code_d) has_any(eventresultdetails_in))\r\n  | extend temp_SrcMatch=has_any_ipv4_prefix(id_orig_h_s,src_or_any)\r\n         , temp_DstMatch=has_any_ipv4_prefix(id_resp_h_s,ipaddr_has_any_prefix)\r\n  | extend ASimMatchingIpAddr=case(\r\n                                array_length(src_or_any) == 0 ,\"-\",\r\n                                temp_SrcMatch and temp_DstMatch, \"Both\",\r\n                                temp_SrcMatch, \"SrcIpAddr\",\r\n                                temp_DstMatch, \"DstIpAddr\",\r\n                                \"No match\"\r\n                            )\r\n  | where ASimMatchingIpAddr != \"No match\" \r\n  | project-away temp_*\r\n  | extend EventResult = iff(tolong(status_code_d) >= 400, \"Failure\", \"Success\")\r\n  | where (eventresult == '*' or EventResult =~ eventresult)\r\n  | project-rename\r\n      DvcDescription = hostname_s,\r\n      DstDescription = resp_hostname_s,\r\n      SrcDescription = orig_hostname_s,\r\n      DstIpAddr = id_resp_h_s,\r\n      EventOriginalUid = uid_s,\r\n      HttpContentType = resp_mime_types_s,\r\n      HttpReferrer = referrer_s,\r\n      HttpRequestMethod = method_s,\r\n      HttpUserAgent = user_agent_s,\r\n      DvcId = sensor_uid_s,\r\n      // -- community id is just a hash of addresses and ports, and not unique for the session\r\n      // NetworkSessionId = community_id_s,\r\n      SrcIpAddr = id_orig_h_s,\r\n      SrcSessionId = orig_sluid_s,\r\n      DstSessionId = resp_sluid_s,\r\n      HttpResponseCacheControl = response_cache_control_s,\r\n      HttpRequestCacheControl = request_cache_control_s,\r\n      HttpCookie = cookie_s,\r\n      HttpResponseExpires = response_expires_s,\r\n      HttpIsProxied = is_proxied_b,\r\n      EventOriginalStatusDetails = status_msg_s\r\n  | extend\r\n      DstHostname = iff (DstDescription startswith \"IP-\" or not(DstDescription matches regex HostnameRegex), \"\", DstDescription),\r\n      SrcHostname = iff (SrcDescription startswith \"IP-\" or not(SrcDescription matches regex HostnameRegex), \"\", SrcDescription),\r\n      DvcHostname = iff (DvcDescription startswith \"IP-\" or not(DvcDescription matches regex HostnameRegex), \"\", DvcDescription),\r\n      DstBytes = tolong(resp_ip_bytes_d),\r\n      DstPackets = tolong(resp_pkts_d),\r\n      DstPortNumber = toint(id_resp_p_d),\r\n      EventCount = toint(1),\r\n      EventStartTime = unixtime_milliseconds_todatetime(ts_d),\r\n      EventOriginalSubType = tostring(split(metadata_type_s, '_')[1]),\r\n      EventProduct = 'Vectra Stream',\r\n      EventResultDetails = tostring(toint(status_code_d)),\r\n      HttpRequestBodyBytes = tolong(request_body_len_d),\r\n      HttpResponseBodyBytes = tolong(response_body_len_d),\r\n      HttpRequestHeaderCount = toint(request_header_count_d),\r\n      HttpResponseHeaderCount = toint(response_header_count_d),\r\n      EventSchema = 'WebSession',\r\n      EventSchemaVersion='0.2.3',\r\n      DvcIdType = 'VectraId',\r\n      EventSeverity = iff (EventResult == 'Success', 'Informational', 'Low'),\r\n      EventType = 'HTTPsession',\r\n      EventVendor = 'Vectra AI',\r\n      SrcBytes = tolong(orig_ip_bytes_d),\r\n      SrcPackets = tolong(orig_pkts_d),\r\n      SrcPortNumber = toint(id_orig_p_d),\r\n      Url = strcat('http://', host_s, uri_s)\r\n  | lookup NetworkDirectionLookup on local_orig_b, local_resp_b\r\n  | lookup NetworkProtocolVersionLookup on id_ip_ver_s\r\n  // -- preserving non-normalized important fields\r\n  | extend AdditionalFields = iff (\r\n      pack, \r\n      bag_pack (\r\n        \"first_orig_resp_data_pkt\", first_orig_resp_data_pkt_s,\r\n        \"first_resp_orig_data_pkt\", first_resp_orig_data_pkt_s,\r\n        \"orig_huid\", orig_huid_s,\r\n        \"resp_huid\", resp_huid_s,\r\n        \"community_id\", community_id_s,\r\n        \"resp_multihome\", resp_multihomed_b,\r\n        \"host_multihomed\", host_multihomed_b,\r\n        \"first_orig_resp_data_pkt_time\", unixtime_milliseconds_todatetime(first_orig_resp_data_pkt_time_d),\r\n        \"first_orig_resp_pkt_time\", unixtime_milliseconds_todatetime(first_orig_resp_pkt_time_d),\r\n        \"first_resp_orig_data_pkt_time\", unixtime_milliseconds_todatetime(first_resp_orig_data_pkt_time_d),\r\n        \"first_resp_orig_pkt_time\", unixtime_milliseconds_todatetime(first_resp_orig_pkt_time_d)\r\n      ),\r\n      dynamic([])\r\n    )\r\n  | project-away\r\n      *_d, *_s, *_b, *_g, Computer, MG, ManagementGroupName, RawData, SourceSystem, TenantId\r\n  | extend\r\n      Dst = DstIpAddr,\r\n      Dvc = DvcId,\r\n      EventEndTime = EventStartTime,\r\n      Hostname = DstHostname,\r\n      HttpStatusCode = EventResultDetails,\r\n      IpAddr = SrcIpAddr,\r\n      NetworkBytes = SrcBytes + DstBytes,\r\n      NetworkPackets = SrcPackets + DstPackets,\r\n      //SessionId = NetworkSessionId,\r\n      Src = SrcIpAddr,\r\n      UserAgent = HttpUserAgent \r\n};\r\nparser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, url_has_any=url_has_any, httpuseragent_has_any=httpuseragent_has_any, eventresultdetails_in=eventresultdetails_in, eventresult=eventresult, disabled=disabled, pack=pack)", "params": "starttime:datetime = datetime(null), endtime:datetime = datetime(null), srcipaddr_has_any_prefix:dynamic = dynamic([]), ipaddr_has_any_prefix:dynamic = dynamic([]), url_has_any:dynamic = dynamic([]), httpuseragent_has_any:dynamic = dynamic([]), eventresultdetails_in:dynamic = dynamic([]), eventresult:string = '*', disabled:bool = false, pack:bool = false"}}