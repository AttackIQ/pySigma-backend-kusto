{"_Im_NetworkSession_VectraAIV02": {"body": "let parser = (\r\n  starttime:datetime=datetime(null), \r\n  endtime:datetime=datetime(null),\r\n  srcipaddr_has_any_prefix:dynamic=dynamic([]), \r\n  dstipaddr_has_any_prefix:dynamic=dynamic([]),\r\n  ipaddr_has_any_prefix:dynamic=dynamic([]),\r\n  dstportnumber:int=int(null), \r\n  hostname_has_any:dynamic=dynamic([]),\r\n  dvcaction:dynamic=dynamic([]), \r\n  eventresult:string='*', \r\n  disabled:bool=false,\r\n  pack:bool=false)\r\n{\r\n  let NetworkDirectionLookup = datatable(local_orig_b:bool, local_resp_b:bool, NetworkDirection:string)[\r\n    false, true, 'Inbound',\r\n    true, false, 'Outbound',\r\n    true, true, 'Local',\r\n    false, false, 'External'];\r\n  let EventSubTypeLookup = datatable(conn_state_s:string, EventSubType:string)[\r\n    \"S1\", 'Start',\r\n    \"SF\", 'End'];\r\n  let HostnameRegex = @'^[a-zA-Z0-9-]{1,61}$';\r\n  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); \r\n  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix);  \r\n  VectraStream_CL\r\n  | where (isnull(starttime) or TimeGenerated>=starttime)\r\n    and   (isnull(endtime) or TimeGenerated<=endtime)\r\n  | where not(disabled)\r\n  | where metadata_type_s == 'metadata_isession'\r\n  | project-away MG, ManagementGroupName, RawData, SourceSystem, TenantId\r\n  | where array_length(dvcaction) == 0\r\n  | where eventresult == \"*\"\r\n  | where  (isnull(dstportnumber) or dstportnumber==id_resp_p_d)\r\n    and (array_length(hostname_has_any)==0 \r\n      or resp_domain_s has_any (hostname_has_any)\r\n      or resp_hostname_s has_any (hostname_has_any)\r\n      or orig_hostname_s has_any (hostname_has_any)\r\n    )\r\n  | extend temp_SrcMatch=has_any_ipv4_prefix(id_orig_h_s,src_or_any)\r\n         , temp_DstMatch=has_any_ipv4_prefix(id_resp_h_s,dst_or_any)\r\n  | extend ASimMatchingIpAddr=case(\r\n                                array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,\"-\",\r\n                                temp_SrcMatch and temp_DstMatch, \"Both\",\r\n                                temp_SrcMatch, \"SrcIpAddr\",\r\n                                temp_DstMatch, \"DstIpAddr\",\r\n                                \"No match\"\r\n                            )\r\n  | where ASimMatchingIpAddr != \"No match\" \r\n  | project-away temp_*\r\n  | project-rename\r\n      DstIpAddr = id_resp_h_s,\r\n      DvcDescription = hostname_s,\r\n      DstDescription = resp_hostname_s,\r\n      SrcDescription = orig_hostname_s,\r\n      // -- huid does not seem to be unique per device and not mapped for now\r\n      // DstDvcId = resp_huid_s, \r\n      // SrcDvcId = orig_huid_s,\r\n      DvcId = sensor_uid_s,\r\n      // -- community id is just a hash of addresses and ports, and not unique for the session\r\n      // NetworkSessionId = community_id_s,\r\n      SrcIpAddr = id_orig_h_s,\r\n      EventUid = _ItemId\r\n  // -- the domain field may have invalid values. Most of them are IP addresses filtered out, but a small fraction are not filtered.\r\n  | extend resp_domain_s = iff (ipv4_is_match(resp_domain_s, \"0.0.0.0\",0), \"\", resp_domain_s)\r\n  | extend SplitRespDomain = split(resp_domain_s,\".\")\r\n  | extend \r\n      DstDomain = tostring(strcat_array(array_slice(SplitRespDomain, 1, -1), '.')),\r\n      DstFQDN = iif (array_length(SplitRespDomain) > 1, resp_domain_s, ''),\r\n      DstDomainType = iif (array_length(SplitRespDomain) > 1, 'FQDN', '')\r\n  | extend\r\n      DstHostname = case (\r\n          resp_domain_s != \"\", tostring(SplitRespDomain[0]),\r\n          DstDescription startswith \"IP-\" or not(DstDescription matches regex HostnameRegex), \"\",\r\n          DstDescription)\r\n  | project-away SplitRespDomain\r\n  | extend\r\n      SrcHostname = iff (SrcDescription startswith \"IP-\" or not(SrcDescription matches regex HostnameRegex), \"\", SrcDescription),\r\n      DvcHostname = iff (DvcDescription startswith \"IP-\" or not(DvcDescription matches regex HostnameRegex), \"\", DvcDescription),\r\n      NetworkApplicationProtocol = toupper(service_s),\r\n      NetworkProtocol = toupper(protoName_s),\r\n      NetworkProtocolVersion = toupper(id_ip_ver_s),\r\n      Dst = DstIpAddr,\r\n      DstBytes = tolong(resp_ip_bytes_d),\r\n      DstPackets = tolong(resp_pkts_d),\r\n      DstPortNumber = toint(id_resp_p_d),\r\n      DstVlanId = tostring(toint(resp_vlan_id_d)),\r\n      EventCount = toint(1),\r\n      EventEndTime = unixtime_milliseconds_todatetime(ts_d),\r\n      EventOriginalSubType = tostring(split(metadata_type_s, '_')[1]),\r\n      EventProduct = 'Vectra Stream',\r\n      EventResult = 'Success',\r\n      EventSchema = 'NetworkSession',\r\n      EventSchemaVersion='0.2.2',\r\n      EventSeverity = 'Informational',\r\n      EventStartTime = unixtime_milliseconds_todatetime(session_start_time_d),\r\n      EventType = 'NetworkSession',\r\n      EventVendor = 'Vectra AI',\r\n      SrcBytes = tolong(orig_ip_bytes_d),\r\n      SrcPackets = tolong(orig_pkts_d),\r\n      SrcPortNumber = toint(id_orig_p_d),\r\n      SrcVlanId = tostring(toint(orig_vlan_id_d)),\r\n      // -- No ID mapped, since huid found not to be unique\r\n      // SrcDvcIdType = 'VectraId',\r\n      // DstDvcIdType = 'VectraId',\r\n      DvcIdType = 'VectraId',\r\n      NetworkDuration = toint(duration_d)\r\n  | extend \r\n      Hostname = DstHostname,\r\n      IpAddr = SrcIpAddr,\r\n      // SessionId = NetworkSessionId,\r\n      Src = SrcIpAddr,\r\n      Dvc = DvcId,\r\n      Duration = NetworkDuration,\r\n      InnerVlanId = SrcVlanId,\r\n      NetworkBytes = SrcBytes + DstBytes,\r\n      NetworkPackets = SrcPackets + DstPackets,\r\n      OuterVlanId = DstVlanId\r\n  | lookup NetworkDirectionLookup on local_orig_b, local_resp_b\r\n  | lookup EventSubTypeLookup on conn_state_s\r\n  // -- preserving non-normalized important fields\r\n  | extend AdditionalFields = iff (\r\n      pack, \r\n      bag_pack (\r\n        \"first_orig_resp_data_pkt\", first_orig_resp_data_pkt_s,\r\n        \"first_resp_orig_data_pkt\", first_resp_orig_data_pkt_s,\r\n        \"orig_sluid\", orig_sluid_s, \r\n        \"resp_sluid\", resp_sluid_s,\r\n        \"orig_huid\", orig_huid_s,\r\n        \"resp_huid\", resp_huid_s,\r\n        \"community_id\", community_id_s,\r\n        \"resp_multihome\", resp_multihomed_b,\r\n        \"host_multihomed\", host_multihomed_b,\r\n        \"first_orig_resp_data_pkt_time\", unixtime_milliseconds_todatetime(first_orig_resp_data_pkt_time_d),\r\n        \"first_orig_resp_pkt_time\", unixtime_milliseconds_todatetime(first_orig_resp_pkt_time_d),\r\n        \"first_resp_orig_data_pkt_time\", unixtime_milliseconds_todatetime(first_resp_orig_data_pkt_time_d),\r\n        \"first_resp_orig_pkt_time\", unixtime_milliseconds_todatetime(first_resp_orig_pkt_time_d)\r\n      ),\r\n      dynamic([])\r\n    )\r\n  | project-away\r\n      *_d, *_s, *_b, *_g, Computer\r\n};\r\nparser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled, pack=pack)\r\n", "params": "starttime:datetime = datetime(null), endtime:datetime = datetime(null), srcipaddr_has_any_prefix:dynamic = dynamic([]), dstipaddr_has_any_prefix:dynamic = dynamic([]), ipaddr_has_any_prefix:dynamic = dynamic([]), dstportnumber:int = int(null), hostname_has_any:dynamic = dynamic([]), dvcaction:dynamic = dynamic([]), eventresult:string = '*', disabled:bool = false, pack:bool = false"}}